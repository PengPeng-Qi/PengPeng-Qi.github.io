## demo
[类和对象](/demo/面向对象/index.html)
## 面向对象编程
面向对象的特性：
- 封装性
- 继承性
- 多态性
  
面向过程和面向对象的对比：
- 面向过程：**性能比面向对象高**，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。  
- 面向对象：易维护、易复用、易扩展，由于**面向对象有封装、继承、多态性的特性**，可以设计出低耦合的系统，使系统更加灵活、更加易于维护  

### 类和对象
**类**抽象了对象的公共部分，**泛指**某一大类  
**对象**特指某一个，通过类实例化一个具体的对象  
  
**面向对象的思维特点**：
- 1、抽象对象**共用的属性和行为**组织封装成一个类
- 2、对类进行**实例化**，获取类的对象

#### 创建类
语法：
```js
// 创建类，首字母大写,且没有小括号
class Star {
  // constructor构造函数，可以接受参数，自动返回实例对象
  // 类的共有属性放在constructor中
  constructor(uname) {
    this.uname = uname;
  }

  // 创建方法
  // 类中的函数不需要加function，且函数之间不加逗号分割
  sing(song) {
    console.log(this.uname + song);
  }
}

// 创建实例对象，new生成实例时，自动调用constructor构造函数
var ldh = new Star('刘德华');
var zxy = new Star('张学友');
console.log(ldh.uname); // 刘德华
console.log(zxy.uname); // 张学友

ldh.sing('冰雨');
zxy.sing('李香兰');
```
> `constructor()`方法是类的构造函数，**用于传递参数，返回实例对象**，通过new命令生成对象实例时，自动调用该方法，如果没有显示定义，类内部会自动给我们创建一个`constructor()`

#### 类的继承
`extends`的使用：
```js
class Father {
  constructor() {

  }
  money() {
    console.log(100);
  }
}

class Son extends Father {

}

var son = new Son();
son.money(); // 100
```
`super()`调用父类中的构造函数`constructor()`：
```js
class Father {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    sum() {
        console.log(this.x + this.y);
    }
}

class Son extends Father {
    constructor(x, y) {
        super(x, y); //调用了父类中的构造函数,把子类的xy传递给父类
    }
}

var son = new Son(1, 2);
var son1 = new Son(11, 22);
son.sum();  // 3
son1.sum(); // 33
```
`super`调用父类普通函数以及继承中属性方法**就近原则**：
```js
// super 关键字调用父类普通函数
class Father {
    say() {
        return '我是爸爸';
    }
}
class Son extends Father {
    say() {
        console.log(super.say() + '的儿子');
        // super.say() 就是调用父类中的普通函数 say()
    }
}
var son = new Son();
son.say();
// 继承中的属性或者方法查找原则: 就近原则
// 1. 继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的
// 2. 继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这个方法(就近原则)
```
`super()`必须放在子类this之前调用
```js
// 父类有加法方法
class Father {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    sum() {
        console.log(this.x + this.y);
    }
}
// 子类继承父类加法方法 同时 扩展减法方法
class Son extends Father {
    constructor(x, y) {
        // 利用super 调用父类的构造函数
        // super 必须在子类this之前调用
        super(x, y);
        this.x = x;
        this.y = y;

    }
    subtract() {
        console.log(this.x - this.y);
    }
}
var son = new Son(5, 3);
son.subtract();  // 2
son.sum();       // 8
```
类中的三个注意点：
- 1、在ES6中**类没有变量提升**，所以必须先定义好类，才能通过类创建实例对象 
- 2、类里面的共有属性和方法一定要加this使用
- 3、类里面this的指向问题
  
类里面的共有属性和方法一定要加`this`使用
```html
<button>点击</button>
<script>
    var that, thatFunction;
    class Star() {
    constructor(uname, age) {
        // constructor里面的this指向的是创建的实例对象ldh
        // console.log(this);
        that = this;

        this.uname = uname;
        this.age = age;
        // 如果想在new的时候调用方法，可在constructor里面调用
        // sing(); 注意，sing()必须使用实例化this调用
        // this.sing();

        // 注意this实例化
        // this.btn = document.querySelector('button');
        // this.btn.onclick = this.sing;
        // 注意this.sing后没有没有加this.sing()，因为加了()会立马调用，我们想点击之后再调用所以不加()

    }
    sing() {
        // sing()里面需要constructor实例化里面的uname
        // console.log(uname); 
        // 当上面btn不存在没有调用sing()时，sing()里面没有uname， this指向实例化，所以这里使用this.uname
        console.log(this.uname);

        // 当上面btn存在且调用sing()时，sing()里面的this指向btn这个按钮，因为这个按钮调用了这个函数
        // console.log(this); <button>点击</button>
        // console.log(this.uname); undefined,因为btn里面没有uname，如果想使用constructor里面的uname，可以使用上面存储的that,that存储的是constructor里面的this
        // console.log(that.uname);
    }
    dance() {
        // 这个方法里面的this指向的也是创建的实例对象ldh
        thatFunction = this;
    }
}
var ldh = new Star('刘德华');
console.log(that === ldh); // true
console.log(thatFunction === ldh); // true
ldh.sing();
</script>
```
> `constructor`里面的this指向实例化，而方法里面的`this`指向方法的调用者

### 构造函数和原型对象
在ES6之前，对象不是基于类创建的，而是用一种称为**构造函数**的特殊函数来定义对象和它们的特征。  
  
构造函数通过原型分配的函数是所有的对象所共享的。  
  
#### 构造函数原型prototype
每一个构造函数都有一个`prototype`属性，指向另一个对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。  
  
**我们可以把那些不变的方法，直接定义在prototype对象上，这样所以对象的实例就可以共享这些方法。**  
```js
// 1. 构造函数的问题. 
function Star(uname, age) {
    this.uname = uname;
    this.age = age;
    // this.sing = function() {
    //     console.log('我会唱歌');

    // }
}
Star.prototype.sing = function() {
    console.log('我会唱歌');
}
var ldh = new Star('刘德华', 18);
var zxy = new Star('张学友', 19);
console.log(ldh.sing === zxy.sing); // true
// console.dir(Star);
ldh.sing();
zxy.sing();
// 2. 一般情况下,我们的公共属性定义到构造函数里面, 公共的方法我们放到原型对象身上

console.log(ldh); // 对象身上系统自己添加一个 __proto__ 指向我们构造函数的原型对象 prototype
console.log(ldh.__proto__ === Star.prototype);
// 方法的查找规则: 首先先看ldh 对象身上是否有 sing 方法,如果有就执行这个对象上的sing
// 如果没有sing 这个方法,因为有__proto__ 的存在,就去构造函数原型对象prototype身上去查找sing这个方法
```
#### constructor构造函数
`对象原型(__proto__)`和`构造函数(prototype)原型对象`里面都有一个属性`constructor`属性，constructor我们称为构造函数，因为它**指回构造函数本身**。  
```js
function Star(uname, age) {
    this.uname = uname;
    this.age = age;
}
// 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数
// Star.prototype.sing = function() {
//     console.log('我会唱歌');
// };
// Star.prototype.movie = function() {
//     console.log('我会演电影');
// }
Star.prototype = {
    // 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数
    constructor: Star,
    sing: function() {
        console.log('我会唱歌');
    },
    movie: function() {
        console.log('我会演电影');
    }
}
var ldh = new Star('刘德华', 18);
var zxy = new Star('张学友', 19);
console.log(Star.prototype);
console.log(ldh.__proto__);
console.log(Star.prototype.constructor);
console.log(ldh.__proto__.constructor);
```
#### call()    
`call()`调用这个函数，并且修改函数运行时的this指向。语法：`fn.call(thisArg, arg1, arg2, ...)`  
- `this.Arg`：当前调用函数this的指向对象
- `arg1、arg2`：传递的其他参数  
  
```js
// call 方法
function fn(x, y) {
    console.log('我想喝手磨咖啡');
    console.log(this);
    console.log(x + y);
}
var o = {
    name: 'andy'
};
// fn();
// 1. call() 可以调用函数
// fn.call();
// 2. call() 可以改变这个函数的this指向 此时这个函数的this 就指向了o这个对象
fn.call(o, 1, 2); 
// {name: 'andy'}
// 3
```
在ES6之前，没有提供`extends`继承，我们可以通过**构造函数+原型对象**模拟实现继承，被称为组合继承。  
  
借用父构造函数**继承属性**：  
```js
// 1. 父构造函数
function Father(uname, age) {
    // this 指向父构造函数的对象实例
    this.uname = uname;
    this.age = age;
}
// 2 .子构造函数 
function Son(uname, age, score) {
    // this 指向子构造函数的对象实例
    Father.call(this, uname, age);
    console.log(this);  // Son{uname: '刘德华', age: 18}
    this.score = score;
}
var son = new Son('刘德华', 18, 100);
console.log(son); // Son{uname: '刘德华', age: 18, score: 100}
```
利用原型对象**继承方法**：  
### 数组方法
迭代(遍历)方法：`forEach()`、`map()`、`filter()`、`some()`、`every()`  
`forEach()`：`array.forEach(function(currentValue, index, arr))`
- `currentValue`；数组当前项的值 
- `index`：数组当前项的索引
- `arr`：数组对象本身

```js
// forEach 迭代(遍历) 数组
var arr = [1, 2, 3];
var sum = 0;
arr.forEach(function(value, index, array) {
    console.log('每个数组元素' + value);
    console.log('每个数组元素的索引号' + index);
    console.log('数组本身' + array);
    sum += value;
    // return true;
    // forEach里面的return并不会终止迭代，类似于continue
})
```
`filter()`方法**创建一个新的数组**，新数组中的元素是通过检查指定数组中符合条件的所有元素,主要用于**筛选数组**，注意它直接**返回一个新数组**。  
`filter()`：`array.filter(function(currentValue, index, arr))`  
```js
// filter 筛选数组
var arr = [12, 66, 4, 88, 3, 7];
var newArr = arr.filter(function(value, index, arr) {
    // return value >= 20;
    return value % 2 === 0;
    // filter里面的return true里面也不能终止迭代
});
console.log(newArr);  // [12, 66, 4, 88]
```
`some()`方法用于检**测数组中的元素是否满足指定条件**。注意它返回值是**布尔值**，如果查找到这个元素，就返回true，如果查找不到就返回false。如果找到第一个满足条件的元素，则终止循环。  
`some()`：`array.some(function(currentValue, index, arr))`  
```js
// some 查找数组中是否有满足条件的元素 
var arr = [10, 30, 4];
var flag = arr.some(function(value) {
    return value >= 20;
    // 在some中，如果遇到return true，则终止迭代，和forEach不同
    // 所以在some中，判断条件之后都会加一个return true
});
console.log(flag);  // true
```
### 字符串方法
`trim()`方法会从一个字符串的**两端**删除空白字符, 不影响字符串本身，**返回的是一个新的字符串**。`trim:调整`  
### 对象方法
`Object.keys(对象名)`用于获取对象自身所有的属性，效果类似与`for...in`，返回一个由**属性名组成的数组**。  
`Object.defineProperty(obj, prop, descriptor)`
```js
// Object.defineProperty() 定义新属性或修改原有的属性
var obj = {
    id: 1,
    pname: '小米',
    price: 1999
};
// 1. 以前的对象添加和修改属性的方式
// obj.num = 1000;
// obj.price = 99;
// console.log(obj);

// 2. Object.defineProperty() 定义新属性或修改原有的属性
Object.defineProperty(obj, 'num', {
    value: 1000,
    enumerable: true
});
Object.defineProperty(obj, 'price', {
    value: 9.9
});

Object.defineProperty(obj, 'address', {
    value: '中国山东蓝翔技校xx单元',
    // 如果只为false 不允许修改这个属性值 默认值也是false
    writable: false,
    // enumerable 如果值为false 则不允许遍历, 默认的值是 false
    enumerable: false,
    // configurable 如果为false 则不允许删除这个属性 不允许在修改第三个参数里面的特性 默认为false
    configurable: false
});
Object.defineProperty(obj, 'address', {
    value: '中国山东蓝翔技校xx单元',
    writable: true,
    enumerable: true,
    configurable: true
}); // 因为上面configurable已经设置过为false了，所以之后的所有修改无效
```
### 函数进阶
#### 函数的定义和调用
1、函数声明方式function关键字  
2、函数表达式（匿名函数）  
3、`new Function()`  

#### this
#### 严格模式
#### 高阶函数
#### 闭包
#### 递归
### 箭头函数
### Let、Const、Var
#### Let
1、使用`Let`关键字声明的变量**具有块级作用域**。可阻止循环变量变成全局变量。  
2、使用`Let`关键字声明的变量**不具有变量提升**  
3、使用`Let`关键字声明的变量在块级作用域下**具有暂时性死区**。  

```js
var arr = [];

for (var i = 0; i < 2; i++) {
    arr[i] = function () {
        console.log(i);
    }
}

arr[0](); // 2 i = 2
arr[1](); // 2 i = 2

let arr = [];

for (let i = 0; i < 2; i++) {
    arr[i] = function () {
        console.log(i);
    }
}

arr[0](); // 0 i = 0
arr[1](); // 1 i = 1
```
#### Const
声明常量，常量就是值（内存地址）不能变化的值。  
  
1、具有**块级作用域**  
2、声明常量时必须赋值，**不具有变量提升**  
3、常量赋值后，**值（值对应的地址）不能更改**  

```js
const PI = 3.14;
PI = 100; // 报错

const ary = [100, 200];
ary[0] = 123; // 复杂数据类型里面的值可以更改，arr = [123, 200]
ary = [1, 2]; // 报错，不能直接赋值
```
### 解构赋值
按照一定模式从数组和对象中提取值，对变量进行赋值。  
数组解构：  
```js
// 数组解构允许我们按照一一对应的关系从数组中提取值 然后将值赋值给变量
let ary = [1,2,3];
let [a, b, c, d] = ary;
console.log(a) // 2
console.log(b) // 2
console.log(c) // 3
console.log(d) // undefined
```
对象解构：  
```js
// 对象解构允许我们使用变量的名字匹配对象的属性 匹配成功 将对象属性的值赋值给变量

let person = {name: 'lisi', age: 30, sex: '男'};
// let { name, age, sex } = person;
// console.log(name) // lisi
// console.log(age)  // 30
// console.log(sex)  // 男

let {name: myName} = person;
console.log(myName) // lisi
```
### 箭头函数
允许使用`() => {}`
```js
const fn = () => {
    console.log(11);
}
fn();

// 函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号
const sum = (num1, num2) => num1 + num2;
sum(1, 2); // 3

// 如果形参只有一个，形参外侧可以省略小括号
const fn = v => alert(v);
fn(1);
```
箭头函数不绑定`this`关键字，箭头函数中的`this`，指向的是函数定义位置的上下文`this`。